{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as queryString from 'query-string';\nimport fromEntries from \"./fromEntries\";\nimport validatePathConfig from \"./validatePathConfig\";\n\nvar getActiveRoute = function getActiveRoute(state) {\n  var route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\nexport default function getPathFromState(state, options) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  var configs = options !== null && options !== void 0 && options.screens ? createNormalizedConfigs(options === null || options === void 0 ? void 0 : options.screens) : {};\n  var path = '/';\n  var current = state;\n  var allParams = {};\n\n  var _loop = function _loop() {\n    var index = typeof current.index === 'number' ? current.index : 0;\n    var route = current.routes[index];\n    var pattern = void 0;\n    var focusedParams = void 0;\n    var focusedRoute = getActiveRoute(state);\n    var currentOptions = configs;\n    var nestedRouteNames = [];\n    var hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        (function () {\n          var stringify = (_currentOptions$route = currentOptions[route.name]) === null || _currentOptions$route === void 0 ? void 0 : _currentOptions$route.stringify;\n          var currentParams = fromEntries(Object.entries(route.params).map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                key = _ref2[0],\n                value = _ref2[1];\n\n            return [key, stringify !== null && stringify !== void 0 && stringify[key] ? stringify[key](value) : String(value)];\n          }));\n\n          if (pattern) {\n            _extends(allParams, currentParams);\n          }\n\n          if (focusedRoute === route) {\n            focusedParams = _objectSpread({}, currentParams);\n            (_pattern = pattern) === null || _pattern === void 0 ? void 0 : _pattern.split('/').filter(function (p) {\n              return p.startsWith(':');\n            }).forEach(function (p) {\n              var name = getParamName(p);\n\n              if (focusedParams) {\n                delete focusedParams[name];\n              }\n            });\n          }\n        })();\n      }\n\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;\n        var nextRoute = route.state.routes[index];\n        var nestedConfig = currentOptions[route.name].screens;\n\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute;\n          currentOptions = nestedConfig;\n        } else {\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern.split('/').map(function (p) {\n        var name = getParamName(p);\n\n        if (p === '*') {\n          return route.name;\n        }\n\n        if (p.startsWith(':')) {\n          var value = allParams[name];\n\n          if (value === undefined && p.endsWith('?')) {\n            return '';\n          }\n\n          return encodeURIComponent(value);\n        }\n\n        return encodeURIComponent(p);\n      }).join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (var param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          delete focusedParams[param];\n        }\n      }\n\n      var query = queryString.stringify(focusedParams, {\n        sort: false\n      });\n\n      if (query) {\n        path += \"?\" + query;\n      }\n    }\n\n    current = route.state;\n  };\n\n  while (current) {\n    var _currentOptions$route;\n\n    var _pattern;\n\n    _loop();\n  }\n\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n  return path;\n}\n\nvar getParamName = function getParamName(pattern) {\n  return pattern.replace(/^:/, '').replace(/\\?$/, '');\n};\n\nvar joinPaths = function joinPaths() {\n  var _ref3;\n\n  for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n    paths[_key] = arguments[_key];\n  }\n\n  return (_ref3 = []).concat.apply(_ref3, _toConsumableArray(paths.map(function (p) {\n    return p.split('/');\n  }))).filter(Boolean).join('/');\n};\n\nvar createConfigItem = function createConfigItem(config, parentPattern) {\n  var _pattern2;\n\n  if (typeof config === 'string') {\n    var _pattern3 = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return {\n      pattern: _pattern3\n    };\n  }\n\n  var pattern;\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");\n  }\n\n  pattern = config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n  var screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n  return {\n    pattern: (_pattern2 = pattern) === null || _pattern2 === void 0 ? void 0 : _pattern2.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens: screens\n  };\n};\n\nvar createNormalizedConfigs = function createNormalizedConfigs(options, pattern) {\n  return fromEntries(Object.entries(options).map(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n        name = _ref5[0],\n        c = _ref5[1];\n\n    var result = createConfigItem(c, pattern);\n    return [name, result];\n  }));\n};","map":null,"metadata":{},"sourceType":"module"}