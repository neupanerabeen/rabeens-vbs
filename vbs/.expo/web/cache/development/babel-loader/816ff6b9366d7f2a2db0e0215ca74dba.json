{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _extends from \"@babel/runtime/helpers/extends\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { useEffect, useRef, useCallback } from 'react';\nimport WorkletEventHandler from \"./WorkletEventHandler\";\nimport { startMapper, stopMapper, makeMutable, makeRemote, requestFrame, getTimestamp } from \"./core\";\nimport updateProps, { updatePropsJestWrapper } from \"./UpdateProps\";\nimport { initialUpdaterRun, cancelAnimation } from \"./animations\";\nimport { getTag } from \"./NativeMethods\";\nimport NativeReanimated from \"./NativeReanimated\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nexport function useSharedValue(init) {\n  var ref = useRef(null);\n\n  if (ref.current === null) {\n    ref.current = makeMutable(init);\n  }\n\n  useEffect(function () {\n    return function () {\n      cancelAnimation(ref.current);\n    };\n  }, []);\n  return ref.current;\n}\nexport function useEvent(handler) {\n  var eventNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var rebuild = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var initRef = useRef(null);\n\n  if (initRef.current === null) {\n    initRef.current = new WorkletEventHandler(handler, eventNames);\n  } else if (rebuild) {\n    initRef.current.updateWorklet(handler);\n  }\n\n  useEffect(function () {\n    return function () {\n      initRef.current = null;\n    };\n  }, []);\n  return initRef;\n}\n\nfunction prepareAnimation(animatedProp, lastAnimation, lastValue) {\n  'worklet';\n\n  function prepareAnimation(animatedProp, lastAnimation, lastValue) {\n    if (Array.isArray(animatedProp)) {\n      animatedProp.forEach(function (prop, index) {\n        return prepareAnimation(prop, lastAnimation && lastAnimation[index], lastValue && lastValue[index]);\n      });\n      return animatedProp;\n    }\n\n    if (typeof animatedProp === 'object' && animatedProp.onFrame) {\n      var animation = animatedProp;\n      var value = animation.current;\n\n      if (lastValue !== undefined) {\n        if (typeof lastValue === 'object') {\n          if (lastValue.value !== undefined) {\n            value = lastValue.value;\n          } else if (lastValue.onFrame !== undefined) {\n            if ((lastAnimation === null || lastAnimation === void 0 ? void 0 : lastAnimation.current) !== undefined) {\n              value = lastAnimation.current;\n            } else if ((lastValue === null || lastValue === void 0 ? void 0 : lastValue.current) !== undefined) {\n              value = lastValue.current;\n            }\n          }\n        } else {\n          value = lastValue;\n        }\n      }\n\n      animation.callStart = function (timestamp) {\n        animation.onStart(animation, value, timestamp, lastAnimation);\n      };\n\n      animation.callStart(getTimestamp());\n      animation.callStart = null;\n    } else if (typeof animatedProp === 'object') {\n      Object.keys(animatedProp).forEach(function (key) {\n        return prepareAnimation(animatedProp[key], lastAnimation && lastAnimation[key], lastValue && lastValue[key]);\n      });\n    }\n  }\n\n  return prepareAnimation(animatedProp, lastAnimation, lastValue);\n}\n\nfunction runAnimations(animation, timestamp, key, result, animationsActive) {\n  'worklet';\n\n  function runAnimations(animation, timestamp, key, result, animationsActive) {\n    if (!animationsActive.value) {\n      return true;\n    }\n\n    if (Array.isArray(animation)) {\n      result[key] = [];\n      var allFinished = true;\n      animation.forEach(function (entry, index) {\n        if (!runAnimations(entry, timestamp, index, result[key], animationsActive)) {\n          allFinished = false;\n        }\n      });\n      return allFinished;\n    } else if (typeof animation === 'object' && animation.onFrame) {\n      var finished = true;\n\n      if (!animation.finished) {\n        if (animation.callStart) {\n          animation.callStart(timestamp);\n          animation.callStart = null;\n        }\n\n        finished = animation.onFrame(animation, timestamp);\n        animation.timestamp = timestamp;\n\n        if (finished) {\n          animation.finished = true;\n          animation.callback && animation.callback(true);\n        }\n      }\n\n      result[key] = animation.current;\n      return finished;\n    } else if (typeof animation === 'object') {\n      result[key] = {};\n      var _allFinished = true;\n      Object.keys(animation).forEach(function (k) {\n        if (!runAnimations(animation[k], timestamp, k, result[key], animationsActive)) {\n          _allFinished = false;\n        }\n      });\n      return _allFinished;\n    } else {\n      result[key] = animation;\n      return true;\n    }\n  }\n\n  return runAnimations(animation, timestamp, key, result, animationsActive);\n}\n\nfunction isAnimated(prop) {\n  'worklet';\n\n  function isAnimated(prop) {\n    if (Array.isArray(prop)) {\n      return prop.some(isAnimated);\n    }\n\n    if (typeof prop === 'object') {\n      if (prop.onFrame) {\n        return true;\n      }\n\n      return Object.keys(prop).some(function (key) {\n        return isAnimated(prop[key]);\n      });\n    }\n\n    return false;\n  }\n\n  return isAnimated(prop);\n}\n\nfunction styleDiff(oldStyle, newStyle) {\n  'worklet';\n\n  var diff = {};\n  Object.keys(oldStyle).forEach(function (key) {\n    if (newStyle[key] === undefined) {\n      diff[key] = null;\n    }\n  });\n  Object.keys(newStyle).forEach(function (key) {\n    var value = newStyle[key];\n    var oldValue = oldStyle[key];\n\n    if (isAnimated(value)) {\n      return;\n    }\n\n    if (oldValue !== value && JSON.stringify(oldValue) !== JSON.stringify(value)) {\n      diff[key] = value;\n    }\n  });\n  return diff;\n}\n\nvar validateAnimatedStyles = function validateAnimatedStyles(styles) {\n  'worklet';\n\n  if (typeof styles !== 'object') {\n    throw new Error(\"useAnimatedStyle has to return an object, found \" + typeof styles + \" instead\");\n  } else if (Array.isArray(styles)) {\n    throw new Error('useAnimatedStyle has to return an object and cannot return static styles combined with dynamic ones. Please do merging where a component receives props.');\n  }\n};\n\nfunction styleUpdater(viewDescriptor, updater, state, maybeViewRef, adapters, animationsActive) {\n  'worklet';\n\n  var animations = state.animations || {};\n  var newValues = updater() || {};\n  var oldValues = state.last;\n  var hasAnimations = false;\n  Object.keys(animations).forEach(function (key) {\n    var value = newValues[key];\n\n    if (!isAnimated(value)) {\n      delete animations[key];\n    }\n  });\n  Object.keys(newValues).forEach(function (key) {\n    var value = newValues[key];\n\n    if (isAnimated(value)) {\n      prepareAnimation(value, animations[key], oldValues[key]);\n      animations[key] = value;\n      hasAnimations = true;\n    }\n  });\n\n  function frame(timestamp) {\n    var animations = state.animations,\n        last = state.last,\n        isAnimationCancelled = state.isAnimationCancelled;\n\n    if (isAnimationCancelled) {\n      state.isAnimationRunning = false;\n      return;\n    }\n\n    var updates = {};\n    var allFinished = true;\n    Object.keys(animations).forEach(function (propName) {\n      var finished = runAnimations(animations[propName], timestamp, propName, updates, animationsActive);\n\n      if (finished) {\n        last[propName] = updates[propName];\n        delete animations[propName];\n      } else {\n        allFinished = false;\n      }\n    });\n\n    if (Object.keys(updates).length) {\n      updateProps(viewDescriptor, updates, maybeViewRef, adapters);\n    }\n\n    if (!allFinished) {\n      requestFrame(frame);\n    } else {\n      state.isAnimationRunning = false;\n    }\n  }\n\n  if (hasAnimations) {\n    state.animations = animations;\n\n    if (!state.isAnimationRunning) {\n      state.isAnimationCancelled = false;\n      state.isAnimationRunning = true;\n\n      if (_frameTimestamp) {\n        frame(_frameTimestamp);\n      } else {\n        requestFrame(frame);\n      }\n    }\n  } else {\n    state.isAnimationCancelled = true;\n    state.animations = {};\n  }\n\n  var diff = styleDiff(oldValues, newValues);\n  state.last = _extends({}, oldValues, newValues);\n\n  if (Object.keys(diff).length !== 0) {\n    updateProps(viewDescriptor, diff, maybeViewRef, adapters);\n  }\n}\n\nfunction jestStyleUpdater(viewDescriptor, updater, state, maybeViewRef, adapters, animationsActive, animatedStyle) {\n  'worklet';\n\n  var animations = state.animations || {};\n  var newValues = updater() || {};\n  var oldValues = state.last;\n  var hasAnimations = false;\n  Object.keys(animations).forEach(function (key) {\n    var value = newValues[key];\n\n    if (!isAnimated(value)) {\n      delete animations[key];\n    }\n  });\n  Object.keys(newValues).forEach(function (key) {\n    var value = newValues[key];\n\n    if (isAnimated(value)) {\n      prepareAnimation(value, animations[key], oldValues[key]);\n      animations[key] = value;\n      hasAnimations = true;\n    }\n  });\n\n  function frame(timestamp) {\n    var animations = state.animations,\n        last = state.last,\n        isAnimationCancelled = state.isAnimationCancelled;\n\n    if (isAnimationCancelled) {\n      state.isAnimationRunning = false;\n      return;\n    }\n\n    var updates = {};\n    var allFinished = true;\n    Object.keys(animations).forEach(function (propName) {\n      var finished = runAnimations(animations[propName], timestamp, propName, updates, animationsActive);\n\n      if (finished) {\n        last[propName] = updates[propName];\n        delete animations[propName];\n      } else {\n        allFinished = false;\n      }\n    });\n\n    if (Object.keys(updates).length) {\n      updatePropsJestWrapper(viewDescriptor, updates, maybeViewRef, adapters, animatedStyle);\n    }\n\n    if (!allFinished) {\n      requestFrame(frame);\n    } else {\n      state.isAnimationRunning = false;\n    }\n  }\n\n  if (hasAnimations) {\n    state.animations = animations;\n\n    if (!state.isAnimationRunning) {\n      state.isAnimationCancelled = false;\n      state.isAnimationRunning = true;\n\n      if (_frameTimestamp) {\n        frame(_frameTimestamp);\n      } else {\n        requestFrame(frame);\n      }\n    }\n  } else {\n    state.isAnimationCancelled = true;\n    state.animations = {};\n  }\n\n  var diff = styleDiff(oldValues, newValues);\n  state.last = _extends({}, oldValues, newValues);\n\n  if (Object.keys(diff).length !== 0) {\n    updatePropsJestWrapper(viewDescriptor, diff, maybeViewRef, adapters, animatedStyle);\n  }\n}\n\nexport function useAnimatedStyle(updater, dependencies, adapters) {\n  var viewDescriptor = useSharedValue({\n    tag: -1,\n    name: null\n  }, false);\n  var initRef = useRef(null);\n  var inputs = Object.values(updater._closure);\n  var viewRef = useRef(null);\n  adapters = !adapters || Array.isArray(adapters) ? adapters : [adapters];\n  var adaptersHash = adapters ? buildWorkletsHash(adapters) : null;\n  var animationsActive = useSharedValue(true);\n  var animatedStyle;\n\n  if (process.env.JEST_WORKER_ID) {\n    animatedStyle = useRef({});\n  }\n\n  if (!dependencies) {\n    dependencies = [].concat(_toConsumableArray(inputs), [updater.__workletHash]);\n  } else {\n    dependencies.push(updater.__workletHash);\n  }\n\n  adaptersHash && dependencies.push(adaptersHash);\n\n  if (initRef.current === null) {\n    var _initial = initialUpdaterRun(updater);\n\n    validateAnimatedStyles(_initial);\n    initRef.current = {\n      initial: _initial,\n      remoteState: makeRemote({\n        last: _initial\n      })\n    };\n  }\n\n  var _initRef$current = initRef.current,\n      remoteState = _initRef$current.remoteState,\n      initial = _initRef$current.initial;\n  var maybeViewRef = NativeReanimated.native ? undefined : viewRef;\n  useEffect(function () {\n    var fun;\n\n    if (process.env.JEST_WORKER_ID) {\n      fun = function fun() {\n        'worklet';\n\n        jestStyleUpdater(viewDescriptor, updater, remoteState, maybeViewRef, adapters, animationsActive, animatedStyle);\n      };\n    } else {\n      fun = function fun() {\n        'worklet';\n\n        styleUpdater(viewDescriptor, updater, remoteState, maybeViewRef, adapters, animationsActive);\n      };\n    }\n\n    var mapperId = startMapper(fun, inputs, []);\n    return function () {\n      stopMapper(mapperId);\n    };\n  }, dependencies);\n  useEffect(function () {\n    animationsActive.value = true;\n    return function () {\n      initRef.current = null;\n      viewRef.current = null;\n      animationsActive.value = false;\n    };\n  }, []);\n  var wrongKey;\n\n  var isObjectValid = function isObjectValid(element, key) {\n    var result = typeof element === 'object' && element.value !== undefined;\n\n    if (result) {\n      wrongKey = key;\n    }\n\n    return !result;\n  };\n\n  var isError = Object.keys(initial).some(function (key) {\n    var element = initial[key];\n    var result = false;\n\n    if (Array.isArray(element)) {\n      for (var _iterator = _createForOfIteratorHelperLoose(element), _step; !(_step = _iterator()).done;) {\n        var elementArrayItem = _step.value;\n\n        if (typeof elementArrayItem !== 'object') {\n          break;\n        }\n\n        var objectValue = Object.values(elementArrayItem)[0];\n        result = isObjectValid(objectValue, key);\n\n        if (!result) {\n          break;\n        }\n      }\n    } else {\n      result = isObjectValid(element, key);\n    }\n\n    return !result;\n  });\n\n  if (isError && wrongKey !== undefined) {\n    throw new Error(\"invalid value passed to `\" + wrongKey + \"`, maybe you forgot to use `.value`?\");\n  }\n\n  if (process.env.JEST_WORKER_ID) {\n    return {\n      viewDescriptor: viewDescriptor,\n      initial: initial,\n      viewRef: viewRef,\n      animatedStyle: animatedStyle\n    };\n  } else {\n    return {\n      viewDescriptor: viewDescriptor,\n      initial: initial,\n      viewRef: viewRef\n    };\n  }\n}\nexport var useAnimatedProps = useAnimatedStyle;\nexport function useDerivedValue(processor, dependencies) {\n  var initRef = useRef(null);\n  var inputs = Object.values(processor._closure);\n\n  if (dependencies === undefined) {\n    dependencies = [].concat(_toConsumableArray(inputs), [processor.__workletHash]);\n  } else {\n    dependencies.push(processor.__workletHash);\n  }\n\n  if (initRef.current === null) {\n    initRef.current = makeMutable(initialUpdaterRun(processor));\n  }\n\n  var sharedValue = initRef.current;\n  useEffect(function () {\n    var fun = function fun() {\n      'worklet';\n\n      sharedValue.value = processor();\n    };\n\n    var mapperId = startMapper(fun, inputs, [sharedValue]);\n    return function () {\n      stopMapper(mapperId);\n    };\n  }, dependencies);\n  useEffect(function () {\n    return function () {\n      initRef.current = null;\n    };\n  }, []);\n  return sharedValue;\n}\n\nfunction buildWorkletsHash(handlers) {\n  return Object.keys(handlers).reduce(function (previousValue, key) {\n    return previousValue === null ? handlers[key].__workletHash : previousValue.toString() + handlers[key].__workletHash.toString();\n  }, null);\n}\n\nfunction buildDependencies(dependencies, handlers) {\n  if (!dependencies) {\n    dependencies = Object.keys(handlers).map(function (handlerKey) {\n      var handler = handlers[handlerKey];\n      return {\n        workletHash: handler.__workletHash,\n        closure: handler._closure\n      };\n    });\n  } else {\n    dependencies.push(buildWorkletsHash(handlers));\n  }\n\n  return dependencies;\n}\n\nfunction areDependenciesEqual(nextDeps, prevDeps) {\n  function is(x, y) {\n    return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n  }\n\n  var objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n  function areHookInputsEqual(nextDeps, prevDeps) {\n    if (!nextDeps || !prevDeps || prevDeps.length !== nextDeps.length) {\n      return false;\n    }\n\n    for (var i = 0; i < prevDeps.length; ++i) {\n      if (!objectIs(nextDeps[i], prevDeps[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return areHookInputsEqual(nextDeps, prevDeps);\n}\n\nexport function useAnimatedGestureHandler(handlers, dependencies) {\n  var initRef = useRef(null);\n\n  if (initRef.current === null) {\n    initRef.current = {\n      context: makeRemote({}),\n      savedDependencies: []\n    };\n  }\n\n  useEffect(function () {\n    return function () {\n      initRef.current = null;\n    };\n  }, []);\n  var _initRef$current2 = initRef.current,\n      context = _initRef$current2.context,\n      savedDependencies = _initRef$current2.savedDependencies;\n  dependencies = buildDependencies(dependencies, handlers);\n  var dependenciesDiffer = !areDependenciesEqual(dependencies, savedDependencies);\n  initRef.current.savedDependencies = dependencies;\n\n  var handler = function handler(event) {\n    'worklet';\n\n    event = Platform.OS === 'web' ? event.nativeEvent : event;\n    var FAILED = 1;\n    var BEGAN = 2;\n    var CANCELLED = 3;\n    var ACTIVE = 4;\n    var END = 5;\n\n    if (event.state === BEGAN && handlers.onStart) {\n      handlers.onStart(event, context);\n    }\n\n    if (event.state === ACTIVE && handlers.onActive) {\n      handlers.onActive(event, context);\n    }\n\n    if (event.oldState === ACTIVE && event.state === END && handlers.onEnd) {\n      handlers.onEnd(event, context);\n    }\n\n    if (event.oldState === BEGAN && event.state === FAILED && handlers.onFail) {\n      handlers.onFail(event, context);\n    }\n\n    if (event.oldState === ACTIVE && event.state === CANCELLED && handlers.onCancel) {\n      handlers.onCancel(event, context);\n    }\n\n    if ((event.oldState === BEGAN || event.oldState === ACTIVE) && event.state !== BEGAN && event.state !== ACTIVE && handlers.onFinish) {\n      handlers.onFinish(event, context, event.state === CANCELLED || event.state === FAILED);\n    }\n  };\n\n  if (Platform.OS === 'web') {\n    return handler;\n  }\n\n  return useEvent(handler, ['onGestureHandlerStateChange', 'onGestureHandlerEvent'], dependenciesDiffer);\n}\nexport function useAnimatedScrollHandler(handlers, dependencies) {\n  var initRef = useRef(null);\n\n  if (initRef.current === null) {\n    initRef.current = {\n      context: makeRemote({}),\n      savedDependencies: []\n    };\n  }\n\n  useEffect(function () {\n    return function () {\n      initRef.current = null;\n    };\n  }, []);\n  var _initRef$current3 = initRef.current,\n      context = _initRef$current3.context,\n      savedDependencies = _initRef$current3.savedDependencies;\n  dependencies = buildDependencies(dependencies, handlers);\n  var dependenciesDiffer = !areDependenciesEqual(dependencies, savedDependencies);\n  initRef.current.savedDependencies = dependencies;\n  var subscribeForEvents = ['onScroll'];\n\n  if (handlers.onBeginDrag !== undefined) {\n    subscribeForEvents.push('onScrollBeginDrag');\n  }\n\n  if (handlers.onEndDrag !== undefined) {\n    subscribeForEvents.push('onScrollEndDrag');\n  }\n\n  if (handlers.onMomentumBegin !== undefined) {\n    subscribeForEvents.push('onMomentumScrollBegin');\n  }\n\n  if (handlers.onMomentumEnd !== undefined) {\n    subscribeForEvents.push('onMomentumScrollEnd');\n  }\n\n  return useEvent(function (event) {\n    'worklet';\n\n    var onScroll = handlers.onScroll,\n        onBeginDrag = handlers.onBeginDrag,\n        onEndDrag = handlers.onEndDrag,\n        onMomentumBegin = handlers.onMomentumBegin,\n        onMomentumEnd = handlers.onMomentumEnd;\n\n    if (event.eventName.endsWith('onScroll')) {\n      if (onScroll) {\n        onScroll(event, context);\n      } else if (typeof handlers === 'function') {\n        handlers(event, context);\n      }\n    } else if (onBeginDrag && event.eventName.endsWith('onScrollBeginDrag')) {\n      onBeginDrag(event, context);\n    } else if (onEndDrag && event.eventName.endsWith('onScrollEndDrag')) {\n      onEndDrag(event, context);\n    } else if (onMomentumBegin && event.eventName.endsWith('onMomentumScrollBegin')) {\n      onMomentumBegin(event, context);\n    } else if (onMomentumEnd && event.eventName.endsWith('onMomentumScrollEnd')) {\n      onMomentumEnd(event, context);\n    }\n  }, subscribeForEvents, dependenciesDiffer);\n}\nexport function useAnimatedRef() {\n  var tag = useSharedValue(-1);\n  var ref = useRef(null);\n\n  if (!ref.current) {\n    var fun = function fun(component) {\n      'worklet';\n\n      if (component) {\n        tag.value = getTag(component);\n        fun.current = component;\n      }\n\n      return tag.value;\n    };\n\n    Object.defineProperty(fun, 'current', {\n      value: null,\n      writable: true,\n      enumerable: false\n    });\n    ref.current = fun;\n  }\n\n  return ref.current;\n}\nexport function useAnimatedReaction(prepare, react, dependencies) {\n  var previous = useSharedValue(null);\n\n  if (dependencies === undefined) {\n    dependencies = [Object.values(prepare._closure), Object.values(react._closure), prepare.__workletHash, react.__workletHash];\n  } else {\n    dependencies.push(prepare.__workletHash, react.__workletHash);\n  }\n\n  useEffect(function () {\n    var fun = function fun() {\n      'worklet';\n\n      var input = prepare();\n      react(input, previous.value);\n      previous.value = input;\n    };\n\n    var mapperId = startMapper(fun, Object.values(prepare._closure), []);\n    return function () {\n      stopMapper(mapperId);\n    };\n  }, dependencies);\n}\nexport function useWorkletCallback(fun, deps) {\n  return useCallback(fun, deps);\n}\nexport function createWorklet(fun) {\n  return fun;\n}","map":null,"metadata":{},"sourceType":"module"}