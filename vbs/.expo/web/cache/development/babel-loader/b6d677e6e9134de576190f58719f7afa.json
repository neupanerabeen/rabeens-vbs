{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport ReanimatedModule from \"../../ReanimatedModule\";\nimport AnimatedNode from \"./AnimatedNode\";\nimport InternalAnimatedValue from \"./AnimatedValue\";\nimport { createAnimatedAlways } from \"./AnimatedAlways\";\nimport invariant from 'fbjs/lib/invariant';\nimport createEventObjectProxyPolyfill from \"./createEventObjectProxyPolyfill\";\n\nfunction sanitizeArgMapping(argMapping) {\n  var eventMappings = [];\n  var alwaysNodes = [];\n\n  var getNode = function getNode(node) {\n    if (Platform.OS === 'web' || Platform.OS === 'windows' || Platform.OS === 'macos') {\n      return node;\n    }\n\n    return node.__nodeID;\n  };\n\n  var traverse = function traverse(value, path) {\n    if (value instanceof InternalAnimatedValue) {\n      eventMappings.push(path.concat(getNode(value)));\n    } else if (typeof value === 'object' && value.__val) {\n      eventMappings.push(path.concat(getNode(value.__val)));\n    } else if (typeof value === 'function') {\n      var node = new InternalAnimatedValue(0);\n      alwaysNodes.push(createAnimatedAlways(value(node)));\n      eventMappings.push(path.concat(getNode(node)));\n    } else if (typeof value === 'object') {\n      for (var key in value) {\n        traverse(value[key], path.concat(key));\n      }\n    }\n  };\n\n  invariant(argMapping[0] && argMapping[0].nativeEvent, 'Native driven events only support animated values contained inside `nativeEvent`.');\n  var ev = argMapping[0].nativeEvent;\n\n  if (typeof ev === 'object') {\n    traverse(ev, []);\n  } else if (typeof ev === 'function') {\n    var proxyHandler = {\n      get: function get(target, name) {\n        if (name === '__isProxy') {\n          return true;\n        }\n\n        if (!target[name] && name !== '__val') {\n          target[name] = new Proxy({}, proxyHandler);\n        }\n\n        return target[name];\n      },\n      set: function set(target, prop, value) {\n        if (prop === '__val') {\n          target[prop] = value;\n          return true;\n        }\n\n        return false;\n      }\n    };\n    var proxy = typeof Proxy === 'function' ? new Proxy({}, proxyHandler) : createEventObjectProxyPolyfill();\n    alwaysNodes.push(createAnimatedAlways(ev(proxy)));\n    traverse(proxy, []);\n  }\n\n  return {\n    eventMappings: eventMappings,\n    alwaysNodes: alwaysNodes\n  };\n}\n\nvar AnimatedEvent = function (_AnimatedNode) {\n  _inherits(AnimatedEvent, _AnimatedNode);\n\n  var _super = _createSuper(AnimatedEvent);\n\n  function AnimatedEvent(argMapping) {\n    var _this;\n\n    var _config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, AnimatedEvent);\n\n    var _sanitizeArgMapping = sanitizeArgMapping(argMapping),\n        eventMappings = _sanitizeArgMapping.eventMappings,\n        alwaysNodes = _sanitizeArgMapping.alwaysNodes;\n\n    _this = _super.call(this, {\n      type: 'event',\n      argMapping: eventMappings\n    });\n    _this.__isNative = true;\n    _this._alwaysNodes = alwaysNodes;\n    return _this;\n  }\n\n  _createClass(AnimatedEvent, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"AnimatedEvent, id: \" + this.__nodeID;\n    }\n  }, {\n    key: \"attachEvent\",\n    value: function attachEvent(viewRef, eventName) {\n      for (var i = 0; i < this._alwaysNodes.length; i++) {\n        this._alwaysNodes[i].__attach();\n      }\n\n      this.__attach();\n\n      var viewTag = findNodeHandle(viewRef);\n      ReanimatedModule.attachEvent(viewTag, eventName, this.__nodeID);\n    }\n  }, {\n    key: \"__onEvaluate\",\n    value: function __onEvaluate() {\n      return 0;\n    }\n  }, {\n    key: \"detachEvent\",\n    value: function detachEvent(viewRef, eventName) {\n      for (var i = 0; i < this._alwaysNodes.length; i++) {\n        this._alwaysNodes[i].isNativelyInitialized() && this._alwaysNodes[i].__detach();\n      }\n\n      var viewTag = findNodeHandle(viewRef);\n      ReanimatedModule.detachEvent(viewTag, eventName, this.__nodeID);\n\n      this.__detach();\n    }\n  }]);\n\n  return AnimatedEvent;\n}(AnimatedNode);\n\nexport { AnimatedEvent as default };\nexport function createAnimatedEvent(argMapping, config) {\n  return new AnimatedEvent(argMapping, config);\n}","map":null,"metadata":{},"sourceType":"module"}