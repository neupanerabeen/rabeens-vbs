{"ast":null,"code":"import { cond, sub, divide, multiply, sqrt, add, block, set, exp, sin, cos, eq, or, neq, and, lessThan, greaterThan, proc, min, abs } from \"../base\";\nimport AnimatedValue from \"../core/InternalAnimatedValue\";\nvar MAX_STEPS_MS = 64;\n\nfunction spring(clock, state, config) {\n  var lastTime = cond(state.time, state.time, clock);\n  var deltaTime = min(sub(clock, lastTime), MAX_STEPS_MS);\n  var c = config.damping;\n  var m = config.mass;\n  var k = config.stiffness;\n  var v0 = multiply(-1, state.velocity);\n  var x0 = sub(config.toValue, state.position);\n  var zeta = divide(c, multiply(2, sqrt(multiply(k, m))));\n  var omega0 = sqrt(divide(k, m));\n  var omega1 = multiply(omega0, sqrt(sub(1, multiply(zeta, zeta))));\n  var t = divide(deltaTime, 1000);\n  var sin1 = sin(multiply(omega1, t));\n  var cos1 = cos(multiply(omega1, t));\n  var underDampedEnvelope = exp(multiply(-1, zeta, omega0, t));\n  var underDampedFrag1 = multiply(underDampedEnvelope, add(multiply(sin1, divide(add(v0, multiply(zeta, omega0, x0)), omega1)), multiply(x0, cos1)));\n  var underDampedPosition = sub(config.toValue, underDampedFrag1);\n  var underDampedVelocity = sub(multiply(zeta, omega0, underDampedFrag1), multiply(underDampedEnvelope, sub(multiply(cos1, add(v0, multiply(zeta, omega0, x0))), multiply(omega1, x0, sin1))));\n  var criticallyDampedEnvelope = exp(multiply(-1, omega0, t));\n  var criticallyDampedPosition = sub(config.toValue, multiply(criticallyDampedEnvelope, add(x0, multiply(add(v0, multiply(omega0, x0)), t))));\n  var criticallyDampedVelocity = multiply(criticallyDampedEnvelope, add(multiply(v0, sub(multiply(t, omega0), 1)), multiply(t, x0, omega0, omega0)));\n  var prevPosition = state.prevPosition ? state.prevPosition : new AnimatedValue(0);\n  var isOvershooting = cond(and(config.overshootClamping, neq(config.stiffness, 0)), cond(lessThan(prevPosition, config.toValue), greaterThan(state.position, config.toValue), lessThan(state.position, config.toValue)));\n  var isVelocity = lessThan(abs(state.velocity), config.restSpeedThreshold);\n  var isDisplacement = or(eq(config.stiffness, 0), lessThan(abs(sub(config.toValue, state.position)), config.restDisplacementThreshold));\n  return block([set(prevPosition, state.position), cond(lessThan(zeta, 1), [set(state.position, underDampedPosition), set(state.velocity, underDampedVelocity)], [set(state.position, criticallyDampedPosition), set(state.velocity, criticallyDampedVelocity)]), set(state.time, clock), cond(or(isOvershooting, and(isVelocity, isDisplacement)), [cond(neq(config.stiffness, 0), [set(state.velocity, 0), set(state.position, config.toValue)]), set(state.finished, 1)])]);\n}\n\nvar procSpring = proc(function (finished, velocity, position, time, prevPosition, toValue, damping, mass, stiffness, overshootClamping, restSpeedThreshold, restDisplacementThreshold, clock) {\n  return spring(clock, {\n    finished: finished,\n    velocity: velocity,\n    position: position,\n    time: time,\n    prevPosition: prevPosition\n  }, {\n    toValue: toValue,\n    damping: damping,\n    mass: mass,\n    stiffness: stiffness,\n    overshootClamping: overshootClamping,\n    restDisplacementThreshold: restDisplacementThreshold,\n    restSpeedThreshold: restSpeedThreshold\n  });\n});\nexport default function springAnimation(clock, _ref, _ref2) {\n  var finished = _ref.finished,\n      velocity = _ref.velocity,\n      position = _ref.position,\n      time = _ref.time,\n      prevPosition = _ref.prevPosition;\n  var toValue = _ref2.toValue,\n      damping = _ref2.damping,\n      mass = _ref2.mass,\n      stiffness = _ref2.stiffness,\n      overshootClamping = _ref2.overshootClamping,\n      restDisplacementThreshold = _ref2.restDisplacementThreshold,\n      restSpeedThreshold = _ref2.restSpeedThreshold;\n  return procSpring(finished, velocity, position, time, prevPosition, toValue, damping, mass, stiffness, overshootClamping, restSpeedThreshold, restDisplacementThreshold, clock);\n}","map":null,"metadata":{},"sourceType":"module"}