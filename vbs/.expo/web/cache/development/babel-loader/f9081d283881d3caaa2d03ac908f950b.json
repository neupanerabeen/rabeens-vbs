{"ast":null,"code":"import { always, block, call, clockRunning, cond, set, startClock, stopClock } from \"../base\";\nimport Clock from \"../core/AnimatedClock\";\nimport { evaluateOnce } from \"../derived/evaluateOnce\";\n\nfunction createOldAnimationObject(node, animationStateDefaults, value, config) {\n  var newClock = new Clock();\n  var currentState = animationStateDefaults();\n  var alwaysNode;\n  var isStarted = false;\n  var isDone = false;\n  var wasStopped = false;\n  var animationCallback;\n  var animation = {\n    start: function start(currentAnimationCallback) {\n      animationCallback = currentAnimationCallback;\n\n      if (isStarted) {\n        animationCallback && animationCallback({\n          finished: false\n        });\n        return;\n      }\n\n      if (isDone) {\n        console.warn('Animation has been finished before');\n        return;\n      }\n\n      if (!value.isNativelyInitialized()) {\n        return;\n      }\n\n      isStarted = true;\n      evaluateOnce(set(currentState.position, value), currentState.position, function () {\n        alwaysNode = always(set(value, block([cond(clockRunning(newClock), 0, startClock(newClock)), node(newClock, currentState, config), cond(currentState.finished, [call([], function () {\n          isStarted = false;\n\n          if (!wasStopped) {\n            isDone = true;\n          }\n\n          value.__detachAnimation(animation);\n\n          isDone = true;\n\n          if (!wasStopped) {\n            wasStopped = false;\n          }\n        }), stopClock(newClock)]), currentState.position])));\n\n        value.__attachAnimation(animation);\n\n        alwaysNode.__addChild(value);\n      });\n    },\n    __detach: function __detach() {\n      animationCallback && animationCallback({\n        finished: isDone\n      });\n      animationCallback = null;\n      value.__initialized && alwaysNode.__removeChild(value);\n    },\n    stop: function stop() {\n      if (isDone) {\n        console.warn('Calling stop has no effect as the animation has already completed');\n        return;\n      }\n\n      if (!isStarted) {\n        console.warn(\"Calling stop has no effect as the animation hasn't been started\");\n        return;\n      }\n\n      wasStopped = true;\n      evaluateOnce(set(currentState.finished, 1), currentState.finished);\n    },\n    __stopImmediately_testOnly: function __stopImmediately_testOnly(result) {\n      animation.stop();\n      isDone = result;\n\n      value.__detachAnimation(animation);\n    }\n  };\n  return animation;\n}\n\nexport default function backwardsCompatibleAnimWrapper(node, animationStateDefaults) {\n  return function (clock, state, config) {\n    if (config !== undefined) {\n      return node(clock, state, config);\n    }\n\n    return createOldAnimationObject(node, animationStateDefaults, clock, state);\n  };\n}","map":null,"metadata":{},"sourceType":"module"}