{"ast":null,"code":"import _defineProperty2 from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport * as React from 'react';\nimport createHandler from \"./createHandler\";\nimport PlatformConstants from \"../PlatformConstants\";\nexport var baseProps = ['id', 'enabled', 'minPointers', 'waitFor', 'simultaneousHandlers', 'shouldCancelWhenOutside', 'hitSlop', 'onBegan', 'onFailed', 'onCancelled', 'onActivated', 'onEnded', 'onGestureEvent', 'onHandlerStateChange'];\nexport var TapGestureHandler = createHandler({\n  name: 'TapGestureHandler',\n  allowedProps: [].concat(baseProps, ['maxDurationMs', 'maxDelayMs', 'numberOfTaps', 'maxDeltaX', 'maxDeltaY', 'maxDist', 'minPointers']),\n  config: {}\n});\nexport var FlingGestureHandler = createHandler({\n  name: 'FlingGestureHandler',\n  allowedProps: [].concat(baseProps, ['numberOfPointers', 'direction']),\n  config: {}\n});\n\nvar ForceTouchFallback = function (_React$Component) {\n  _inherits(ForceTouchFallback, _React$Component);\n\n  var _super = _createSuper(ForceTouchFallback);\n\n  function ForceTouchFallback() {\n    _classCallCheck(this, ForceTouchFallback);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ForceTouchFallback, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      console.warn('ForceTouchGestureHandler is not available on this platform. Please use ForceTouchGestureHandler.forceTouchAvailable to conditionally render other components that would provide a fallback behavior specific to your usecase');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children;\n    }\n  }]);\n\n  return ForceTouchFallback;\n}(React.Component);\n\n_defineProperty(ForceTouchFallback, \"forceTouchAvailable\", false);\n\nexport var ForceTouchGestureHandler = PlatformConstants !== null && PlatformConstants !== void 0 && PlatformConstants.forceTouchAvailable ? createHandler({\n  name: 'ForceTouchGestureHandler',\n  allowedProps: [].concat(baseProps, ['minForce', 'maxForce', 'feedbackOnActivation']),\n  config: {}\n}) : ForceTouchFallback;\nForceTouchGestureHandler.forceTouchAvailable = (PlatformConstants === null || PlatformConstants === void 0 ? void 0 : PlatformConstants.forceTouchAvailable) || false;\nexport var LongPressGestureHandler = createHandler({\n  name: 'LongPressGestureHandler',\n  allowedProps: [].concat(baseProps, ['minDurationMs', 'maxDist']),\n  config: {}\n});\n\nfunction validatePanGestureHandlerProps(props) {\n  if (props.minDeltaX && props.activeOffsetX) {\n    throw new Error(\"It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd\");\n  }\n\n  if (props.maxDeltaX && props.failOffsetX) {\n    throw new Error(\"It's not supported use minDeltaX with activeOffsetXStart or activeOffsetXEnd\");\n  }\n\n  if (props.minDeltaY && props.activeOffsetY) {\n    throw new Error(\"It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd\");\n  }\n\n  if (props.maxDeltaY && props.failOffsetY) {\n    throw new Error(\"It's not supported use minDeltaX with activeOffsetYStart or activeOffsetYEnd\");\n  }\n\n  if (Array.isArray(props.activeOffsetX) && (props.activeOffsetX[0] > 0 || props.activeOffsetX[1] < 0)) {\n    throw new Error(\"First element of activeOffsetX should be negative, a the second one should be positive\");\n  }\n\n  if (Array.isArray(props.activeOffsetY) && (props.activeOffsetY[0] > 0 || props.activeOffsetY[1] < 0)) {\n    throw new Error(\"First element of activeOffsetY should be negative, a the second one should be positive\");\n  }\n\n  if (Array.isArray(props.failOffsetX) && (props.failOffsetX[0] > 0 || props.failOffsetX[1] < 0)) {\n    throw new Error(\"First element of failOffsetX should be negative, a the second one should be positive\");\n  }\n\n  if (Array.isArray(props.failOffsetY) && (props.failOffsetY[0] > 0 || props.failOffsetY[1] < 0)) {\n    throw new Error(\"First element of failOffsetY should be negative, a the second one should be positive\");\n  }\n}\n\nfunction transformPanGestureHandlerProps(props) {\n  var res = _objectSpread({}, props);\n\n  if (props.minDeltaX !== undefined) {\n    delete res.minDeltaX;\n    res.activeOffsetXStart = -props.minDeltaX;\n    res.activeOffsetXEnd = props.minDeltaX;\n  }\n\n  if (props.maxDeltaX !== undefined) {\n    delete res.maxDeltaX;\n    res.failOffsetXStart = -props.maxDeltaX;\n    res.failOffsetXEnd = props.maxDeltaX;\n  }\n\n  if (props.minOffsetX !== undefined) {\n    delete res.minOffsetX;\n\n    if (props.minOffsetX < 0) {\n      res.activeOffsetXStart = props.minOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.minOffsetX;\n    }\n  }\n\n  if (props.minDeltaY !== undefined) {\n    delete res.minDeltaY;\n    res.activeOffsetYStart = -props.minDeltaY;\n    res.activeOffsetYEnd = props.minDeltaY;\n  }\n\n  if (props.maxDeltaY !== undefined) {\n    delete res.maxDeltaY;\n    res.failOffsetYStart = -props.maxDeltaY;\n    res.failOffsetYEnd = props.maxDeltaY;\n  }\n\n  if (props.minOffsetY !== undefined) {\n    delete res.minOffsetY;\n\n    if (props.minOffsetY < 0) {\n      res.activeOffsetYStart = props.minOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.minOffsetY;\n    }\n  }\n\n  if (props.activeOffsetX !== undefined) {\n    delete res.activeOffsetX;\n\n    if (Array.isArray(props.activeOffsetX)) {\n      res.activeOffsetXStart = props.activeOffsetX[0];\n      res.activeOffsetXEnd = props.activeOffsetX[1];\n    } else if (props.activeOffsetX < 0) {\n      res.activeOffsetXStart = props.activeOffsetX;\n    } else {\n      res.activeOffsetXEnd = props.activeOffsetX;\n    }\n  }\n\n  if (props.activeOffsetY !== undefined) {\n    delete res.activeOffsetY;\n\n    if (Array.isArray(props.activeOffsetY)) {\n      res.activeOffsetYStart = props.activeOffsetY[0];\n      res.activeOffsetYEnd = props.activeOffsetY[1];\n    } else if (props.activeOffsetY < 0) {\n      res.activeOffsetYStart = props.activeOffsetY;\n    } else {\n      res.activeOffsetYEnd = props.activeOffsetY;\n    }\n  }\n\n  if (props.failOffsetX !== undefined) {\n    delete res.failOffsetX;\n\n    if (Array.isArray(props.failOffsetX)) {\n      res.failOffsetXStart = props.failOffsetX[0];\n      res.failOffsetXEnd = props.failOffsetX[1];\n    } else if (props.failOffsetX < 0) {\n      res.failOffsetXStart = props.failOffsetX;\n    } else {\n      res.failOffsetXEnd = props.failOffsetX;\n    }\n  }\n\n  if (props.failOffsetY !== undefined) {\n    delete res.failOffsetY;\n\n    if (Array.isArray(props.failOffsetY)) {\n      res.failOffsetYStart = props.failOffsetY[0];\n      res.failOffsetYEnd = props.failOffsetY[1];\n    } else if (props.failOffsetY < 0) {\n      res.failOffsetYStart = props.failOffsetY;\n    } else {\n      res.failOffsetYEnd = props.failOffsetY;\n    }\n  }\n\n  return res;\n}\n\nfunction managePanProps(props) {\n  if (__DEV__) {\n    validatePanGestureHandlerProps(props);\n  }\n\n  return transformPanGestureHandlerProps(props);\n}\n\nexport var PanGestureHandler = createHandler({\n  name: 'PanGestureHandler',\n  allowedProps: [].concat(baseProps, ['activeOffsetY', 'activeOffsetX', 'failOffsetY', 'failOffsetX', 'minDist', 'minVelocity', 'minVelocityX', 'minVelocityY', 'minPointers', 'maxPointers', 'avgTouches', 'enableTrackpadTwoFingerGesture']),\n  config: {},\n  transformProps: managePanProps,\n  customNativeProps: ['activeOffsetYStart', 'activeOffsetYEnd', 'activeOffsetXStart', 'activeOffsetXEnd', 'failOffsetYStart', 'failOffsetYEnd', 'failOffsetXStart', 'failOffsetXEnd']\n});\nexport var PinchGestureHandler = createHandler({\n  name: 'PinchGestureHandler',\n  allowedProps: baseProps,\n  config: {}\n});\nexport var RotationGestureHandler = createHandler({\n  name: 'RotationGestureHandler',\n  allowedProps: baseProps,\n  config: {}\n});","map":null,"metadata":{},"sourceType":"module"}