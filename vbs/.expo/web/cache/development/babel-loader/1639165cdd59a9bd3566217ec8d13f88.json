{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } it = o[Symbol.iterator](); return it.next.bind(it); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { lessThan, multiply, sub, add, divide, greaterThan, lessOrEq, eq } from \"../operators\";\nimport invariant from 'fbjs/lib/invariant';\nimport AnimatedNode from \"../core/AnimatedNode\";\nimport { createAnimatedCond as cond } from \"../core/AnimatedCond\";\nimport { createAnimatedFunction as proc } from \"../core/AnimatedFunction\";\nvar interpolateInternalSingleProc = proc(function (value, inS, inE, outS, outE) {\n  var progress = divide(sub(value, inS), sub(inE, inS));\n  var resultForNonZeroRange = add(outS, multiply(progress, sub(outE, outS)));\n  var result = cond(eq(inS, inE), cond(lessOrEq(value, inS), outS, outE), resultForNonZeroRange);\n  return result;\n});\n\nfunction interpolateInternalSingle(value, inputRange, outputRange, offset) {\n  var inS = inputRange[offset];\n  var inE = inputRange[offset + 1];\n  var outS = outputRange[offset];\n  var outE = outputRange[offset + 1];\n  return interpolateInternalSingleProc(value, inS, inE, outS, outE);\n}\n\nfunction interpolateInternal(value, inputRange, outputRange) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  if (inputRange.length - offset === 2) {\n    return interpolateInternalSingle(value, inputRange, outputRange, offset);\n  }\n\n  return cond(lessThan(value, inputRange[offset + 1]), interpolateInternalSingle(value, inputRange, outputRange, offset), interpolateInternal(value, inputRange, outputRange, offset + 1));\n}\n\nexport var Extrapolate = {\n  EXTEND: 'extend',\n  CLAMP: 'clamp',\n  IDENTITY: 'identity'\n};\n\nfunction checkNonDecreasing(name, arr) {\n  for (var i = 1; i < arr.length; ++i) {\n    if (arr[i] instanceof AnimatedNode || arr[i - 1] instanceof AnimatedNode) continue;\n    invariant(arr[i] >= arr[i - 1], '%s must be monotonically non-decreasing. (%s)', name, arr);\n  }\n}\n\nfunction checkMinElements(name, arr) {\n  invariant(arr.length >= 2, '%s must have at least 2 elements. (%s)', name, arr);\n}\n\nfunction checkValidNumbers(name, arr) {\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] instanceof AnimatedNode || typeof arr[i] !== 'number') continue;\n    invariant(Number.isFinite(arr[i]), '%s cannot include %s. (%s)', name, arr[i], arr);\n  }\n}\n\nfunction convertToRadians(outputRange) {\n  for (var _iterator = _createForOfIteratorHelperLoose(outputRange.entries()), _step; !(_step = _iterator()).done;) {\n    var _ref = _step.value;\n\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    var i = _ref2[0];\n    var value = _ref2[1];\n\n    if (typeof value === 'string' && value.endsWith('deg')) {\n      outputRange[i] = parseFloat(value) * (Math.PI / 180);\n    } else if (typeof value === 'string' && value.endsWith('rad')) {\n      outputRange[i] = parseFloat(value);\n    }\n  }\n}\n\nexport default function interpolate(value, config) {\n  var inputRange = config.inputRange,\n      outputRange = config.outputRange,\n      _config$extrapolate = config.extrapolate,\n      extrapolate = _config$extrapolate === void 0 ? Extrapolate.EXTEND : _config$extrapolate,\n      extrapolateLeft = config.extrapolateLeft,\n      extrapolateRight = config.extrapolateRight;\n  checkMinElements('inputRange', inputRange);\n  checkValidNumbers('inputRange', inputRange);\n  checkMinElements('outputRange', outputRange);\n  checkValidNumbers('outputRange', outputRange);\n  checkNonDecreasing('inputRange', inputRange);\n  invariant(inputRange.length === outputRange.length, 'inputRange and outputRange must be the same length.');\n  convertToRadians(outputRange);\n  var left = extrapolateLeft || extrapolate;\n  var right = extrapolateRight || extrapolate;\n  var output = interpolateInternal(value, inputRange, outputRange);\n\n  if (left === Extrapolate.EXTEND) {} else if (left === Extrapolate.CLAMP) {\n    output = cond(lessThan(value, inputRange[0]), outputRange[0], output);\n  } else if (left === Extrapolate.IDENTITY) {\n    output = cond(lessThan(value, inputRange[0]), value, output);\n  }\n\n  if (right === Extrapolate.EXTEND) {} else if (right === Extrapolate.CLAMP) {\n    output = cond(greaterThan(value, inputRange[inputRange.length - 1]), outputRange[outputRange.length - 1], output);\n  } else if (right === Extrapolate.IDENTITY) {\n    output = cond(greaterThan(value, inputRange[inputRange.length - 1]), value, output);\n  }\n\n  return output;\n}","map":null,"metadata":{},"sourceType":"module"}